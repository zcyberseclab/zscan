package stage

import (
	"crypto/tls"
	"fmt"
	"net"
	"net/http"
	"time"
)

func ScanTCPPort(ip string, port int) bool {
	target := fmt.Sprintf("%s:%d", ip, port)
	conn, err := net.DialTimeout("tcp", target, 2*time.Second)
	if err == nil {
		defer conn.Close()
		return true
	}

	commonHTTPPorts := []int{80, 443, 8080, 8443, 8000, 8888}
	for _, httpPort := range commonHTTPPorts {
		if port == httpPort {
			return ScanHTTPPort(ip, port)
		}
	}

	return false
}

func ScanHTTPPort(ip string, port int) bool {
	target := fmt.Sprintf("http://%s:%d", ip, port)

	transport := &http.Transport{
		TLSClientConfig: &tls.Config{
			InsecureSkipVerify: true,
			MinVersion:         tls.VersionTLS10,
			MaxVersion:         tls.VersionTLS13,
		},
		DisableKeepAlives: true,
		DialContext: (&net.Dialer{
			Timeout:   10 * time.Second,
			KeepAlive: 10 * time.Second,
		}).DialContext,
		TLSHandshakeTimeout:   10 * time.Second,
		ResponseHeaderTimeout: 10 * time.Second,
		ExpectContinueTimeout: 10 * time.Second,
	}

	client := &http.Client{
		Transport: transport,
		Timeout:   10 * time.Second,
	}

	resp, err := client.Head(target)
	if err != nil {
		if port == 80 || port == 443 {
			httpsTarget := fmt.Sprintf("https://%s:%d", ip, port)
			resp, err = client.Head(httpsTarget)
			if err != nil {
				return false
			}
		} else {
			return false
		}
	}
	defer resp.Body.Close()
	return true
}

// UDP 探测包定义
var udpProbes = map[int][]byte{
	// DNS - 标准查询 version.bind
	53: {0x00, 0x1e, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x04, 0x62, 0x69, 0x6e, 0x64,
		0x00, 0x00, 0x10, 0x00, 0x03},
	// NTP - Mode 3 Client Request
	123: {0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	// NetBIOS Name Service - NBSTAT query
	137: {0x80, 0xf0, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x43, 0x4b, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
		0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
		0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x00, 0x00, 0x21, 0x00, 0x01},
	// SNMP v1 GetRequest - public community
	161: {0x30, 0x26, 0x02, 0x01, 0x01, 0x04, 0x06, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63,
		0xa0, 0x19, 0x02, 0x04, 0x00, 0x00, 0x00, 0x01, 0x02, 0x01, 0x00, 0x02, 0x01, 0x00,
		0x30, 0x0b, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x06, 0x01, 0x02, 0x01, 0x05, 0x00},
	// SNMP Trap (被动接收，发送空探测)
	162: {0x30, 0x26, 0x02, 0x01, 0x01, 0x04, 0x06, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63,
		0xa0, 0x19, 0x02, 0x04, 0x00, 0x00, 0x00, 0x01, 0x02, 0x01, 0x00, 0x02, 0x01, 0x00,
		0x30, 0x0b, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x06, 0x01, 0x02, 0x01, 0x05, 0x00},
	// TFTP - Read Request for "x"
	69: {0x00, 0x01, 0x78, 0x00, 0x6e, 0x65, 0x74, 0x61, 0x73, 0x63, 0x69, 0x69, 0x00},
	// IKE/IPSec - ISAKMP
	500: {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x01, 0x10, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00},
	// Syslog - 测试消息
	514: []byte("<14>test"),
	// IPMI RMCP - Get Channel Auth
	623: {0x06, 0x00, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x09, 0x20, 0x18, 0xc8, 0x81, 0x00, 0x38, 0x8e, 0x04, 0xb5},
	// OpenVPN - P_CONTROL_HARD_RESET_CLIENT_V2
	1194: {0x38, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	// MSSQL Browser
	1434: {0x02},
	// L2TP - SCCRQ
	1701: {0xc8, 0x02, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x80, 0x08, 0x00, 0x00},
	// RADIUS Access-Request
	1812: {0x01, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	// NAT-T (IPSec over UDP)
	4500: {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x01, 0x10, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00},
	// SIP OPTIONS
	5060: []byte("OPTIONS sip:nm SIP/2.0\r\nVia: SIP/2.0/UDP nm;branch=z9hG4bK\r\nMax-Forwards: 0\r\nTo: <sip:nm>\r\nFrom: <sip:nm>;tag=nm\r\nCall-ID: nm\r\nCSeq: 1 OPTIONS\r\nContent-Length: 0\r\n\r\n"),
	// mDNS - 查询 _services._dns-sd._udp.local
	5353: {0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x09, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x07, 0x5f,
		0x64, 0x6e, 0x73, 0x2d, 0x73, 0x64, 0x04, 0x5f, 0x75, 0x64, 0x70, 0x05,
		0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x00, 0x00, 0x0c, 0x00, 0x01},
}

// ScanUDPPort 使用协议特定的探测包扫描 UDP 端口
func ScanUDPPort(ip string, port int) bool {
	target := fmt.Sprintf("%s:%d", ip, port)
	conn, err := net.DialTimeout("udp", target, 2*time.Second)
	if err != nil {
		return false
	}
	defer conn.Close()

	// 获取探测包，如果没有特定协议的探测包，使用通用探测
	probe, exists := udpProbes[port]
	if !exists {
		// 通用探测：发送空包或简单数据
		probe = []byte{0x00}
	}

	// 设置读写超时
	conn.SetDeadline(time.Now().Add(3 * time.Second))

	// 发送探测包
	_, err = conn.Write(probe)
	if err != nil {
		return false
	}

	// 等待响应
	buf := make([]byte, 1024)
	n, err := conn.Read(buf)
	if err != nil {
		// 检查是否是 ICMP Port Unreachable 错误
		if netErr, ok := err.(net.Error); ok && netErr.Timeout() {
			// 超时 - 可能被过滤，不确定是否开放
			return false
		}
		// 其他错误（如 connection refused）表示端口关闭
		return false
	}

	// 收到响应，端口开放
	return n > 0
}
